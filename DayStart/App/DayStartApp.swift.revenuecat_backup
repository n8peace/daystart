import SwiftUI
import AVFoundation
import UserNotifications
import UIKit
import Combine
import BackgroundTasks
import MediaPlayer
import FirebaseCore
import FirebaseAnalytics
import FirebaseCrashlytics
import RevenueCat

/// Minimal DayStartApp with aggressive service deferral
/// Only loads 3 essential services on startup for Spotify-level performance
@main
struct DayStartApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    // TIER 1: Only essential services (no lazy loading needed)
    private var userPreferences: UserPreferences { UserPreferences.shared }
    @StateObject var themeManager = ThemeManager.shared  // Made internal for auth extension
    
    // Purchase state
    @StateObject var purchaseManager = PurchaseManager.shared
    
    // Logger for auth extension  
    internal let logger = DebugLogger.shared
    
    private static var audioConfigRetryCount = 0
    private static let maxAudioConfigRetries = 3
    
    init() {
        // MINIMAL: Only essential UI setup (no service initialization)
        configureBasicNavigationAppearance()
    }
    
    var body: some Scene {
        WindowGroup {
            authenticatedContentView()
                .onReceive(NotificationCenter.default.publisher(for: AVAudioSession.mediaServicesWereResetNotification)) { _ in
                    Self.audioConfigRetryCount = 0
                    Task {
                        await reconfigureAudioSessionIfNeeded()
                    }
                }
                .onAppear {
                    // DEFERRED: All heavy initialization happens after UI appears
                    Task {
                        await deferredAppInitialization()
                    }
                }
                .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
                    themeManager.refreshColorScheme()
                    
                    // LAZY: Only pre-warm if audio system is already loaded
                    Task.detached {
                        await preWarmLoadedServicesOnForeground()
                    }
                    
                    // Trigger snapshot updates when app comes to foreground
                    Task.detached {
                        await triggerSnapshotUpdateOnForeground()
                    }
                }
                .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name.NSSystemTimeZoneDidChange)) { _ in
                    // Handle timezone changes to maintain alarm clock behavior
                    Task.detached {
                        await handleTimezoneChange()
                    }
                }
        }
    }
    
    // MARK: - Minimal UI Setup (Instant)
    
    private func configureBasicNavigationAppearance() {
        let appearance = UINavigationBarAppearance()
        appearance.configureWithTransparentBackground()
        
        let labelColor = UIColor.label
        appearance.titleTextAttributes = [.foregroundColor: labelColor]
        appearance.largeTitleTextAttributes = [.foregroundColor: labelColor]
        
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        UINavigationBar.appearance().compactAppearance = appearance
        UINavigationBar.appearance().tintColor = UIColor(BananaTheme.ColorToken.accent)
    }
    
    func updateNavigationAppearance(for colorScheme: ColorScheme) {  // Made internal for auth extension
        // Dynamic appearance updates (lightweight)
        configureBasicNavigationAppearance()
    }
    
    // MARK: - Deferred Initialization (Background)
    
    private func deferredAppInitialization() async {
        // CRITICAL: Pre-warm only what prevents keyboard lag
        Task.detached(priority: .background) {
            await self.preWarmKeyboardLagFix()
        }
        
        // DEFERRED: Background cleanup (non-blocking)
        // Only run cleanup if user has completed onboarding
        if UserPreferences.shared.hasCompletedOnboarding {
            Task.detached(priority: .background) {
                await UserPreferences.shared.cleanupOldAudioFiles()
            }
        }
    }
    
    /// Pre-warm only what's essential to prevent keyboard lag
    private func preWarmKeyboardLagFix() async {
        do {
            // 1. Pre-warm MPRemoteCommandCenter (main keyboard lag cause)
            let _ = MPRemoteCommandCenter.shared()
            
            // 2. Configure basic audio session
            try await configureAudioSessionAsync()
            
            DebugLogger.shared.log("‚úÖ Keyboard lag prevention complete", level: .info)
            
        } catch {
            DebugLogger.shared.logError(error, context: "Pre-warming keyboard lag fix")
        }
    }
    
    /// Basic audio session configuration (lightweight)
    private func configureAudioSessionAsync() async throws {
        let audioSession = AVAudioSession.sharedInstance()
        
        try audioSession.setCategory(
            .playback,
            mode: .spokenAudio,
            options: []
        )
        
        try audioSession.setPreferredSampleRate(44100.0)
        try audioSession.setPreferredIOBufferDuration(0.005)
    }
    
    /// Only pre-warm services that are already loaded
    private func preWarmLoadedServicesOnForeground() async {
        await MainActor.run {
            let registry = ServiceRegistry.shared
            
            // Only check for upcoming DayStarts if AudioPrefetchManager is already loaded
            if registry.loadedServices.contains("AudioPrefetchManager") {
                Task {
                    await registry.audioPrefetchManager.checkForUpcomingDayStarts()
                }
            }
            
            // Only pre-warm location if LocationManager is already loaded
            if registry.loadedServices.contains("LocationManager"),
               let locationManager = registry.locationManager {
                Task {
                    _ = await locationManager.getCurrentLocation()
                }
            }
        }
    }
    
    /// Trigger snapshot updates when app enters foreground
    private func triggerSnapshotUpdateOnForeground() async {
        await MainActor.run {
            let registry = ServiceRegistry.shared
            
            // Only trigger if user has active schedule
            guard !UserPreferences.shared.schedule.repeatDays.isEmpty else {
                return
            }
            
            // Initialize SnapshotUpdateManager and trigger foreground update
            Task {
                await registry.snapshotUpdateManager.updateSnapshotsForUpcomingJobs(trigger: .appForeground)
            }
        }
    }
    
    /// Reconfigure audio session only if AudioPlayerManager is loaded
    private func reconfigureAudioSessionIfNeeded() async {
        let hasAudioPlayer = await MainActor.run {
            ServiceRegistry.shared.loadedServices.contains("AudioPlayerManager")
        }
        
        guard hasAudioPlayer else {
            DebugLogger.shared.log("üîÑ Media services reset - but AudioPlayerManager not loaded, skipping", level: .debug)
            return
        }
        
        // Only reconfigure if audio system is actually in use
        Self.audioConfigRetryCount = 0
        
        do {
            try await configureAudioSessionAsync()
            DebugLogger.shared.log("‚úÖ Audio session reconfigured after media services reset", level: .info)
        } catch {
            DebugLogger.shared.logError(error, context: "Reconfiguring audio session after media services reset")
        }
    }
    
    /// Handle timezone changes to maintain alarm clock behavior
    private func handleTimezoneChange() async {
        await MainActor.run {
            let userPreferences = UserPreferences.shared
            
            // Only update if user has active schedule
            guard !userPreferences.schedule.repeatDays.isEmpty else {
                logger.log("üåç Timezone changed but no active schedule - skipping job updates", level: .info)
                return
            }
            
            logger.log("üåç Timezone changed - updating scheduled jobs to maintain local time", level: .info)
            
            // Trigger timezone change handling in UserPreferences
            Task.detached {
                await userPreferences.updateJobsForTimezoneChange()
            }
        }
    }
}

/// Minimal ContentView with lazy service loading
struct ContentView: View {
    // DEFERRED: HomeViewModel loads services only when needed
    @StateObject private var homeViewModel = HomeViewModel()
    
    var body: some View {
        HomeView(viewModel: homeViewModel)
            .onAppear {
                // Load core UI services only when view appears
                homeViewModel.onViewAppear()
            }
            .onDisappear {
                homeViewModel.onViewDisappear()
            }
    }
}

// MARK: - Minimal App Delegate

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
    ) -> Bool {
        DebugLogger.shared.log("üöÄ App didFinishLaunchingWithOptions - START", level: .info)
        
        // Configure Firebase
        DebugLogger.shared.log("üî• Configuring Firebase", level: .info)
        FirebaseApp.configure()
        DebugLogger.shared.log("‚úÖ Firebase configured", level: .info)
        
        // Configure RevenueCat
        DebugLogger.shared.log("üí∞ About to configure RevenueCat", level: .info)
        do {
            configureRevenueCat()
            DebugLogger.shared.log("‚úÖ RevenueCat configuration method completed", level: .info)
        } catch {
            DebugLogger.shared.log("‚ùå FATAL: RevenueCat configuration failed: \(error)", level: .error)
            // Continue app startup even if RevenueCat fails
        }
        
        // REQUIRED: Register all background task handlers before app finishes launching
        DebugLogger.shared.log("üì± Registering background tasks", level: .info)
        registerBackgroundTasks()
        DebugLogger.shared.log("‚úÖ Background tasks registered", level: .info)
        
        DebugLogger.shared.log("üöÄ App didFinishLaunchingWithOptions - COMPLETE", level: .info)
        return true
    }
    
    /// Configure RevenueCat with API key and user identification
    private func configureRevenueCat() {
        DebugLogger.shared.log("üîß Starting RevenueCat configuration in DayStartApp", level: .info)
        
        defer {
            DebugLogger.shared.log("üèÅ Exiting configureRevenueCat method", level: .info)
        }
        
        do {
            // Configure with API key from Info.plist (use sandbox for debug builds)
            DebugLogger.shared.log("üìã Checking Info.plist for API key", level: .info)
            
            #if DEBUG
            // Use sandbox key for debug builds (simulator testing)
            guard let apiKey = Bundle.main.object(forInfoDictionaryKey: "REVENUECAT_SANDBOX_API_KEY") as? String else {
                DebugLogger.shared.log("‚ùå FATAL: RevenueCat sandbox API key not found in Info.plist", level: .error)
                fatalError("RevenueCat sandbox API key not found in Info.plist")
            }
            DebugLogger.shared.log("‚úÖ Sandbox API key found: \(apiKey.prefix(12))...", level: .info)
            #else
            // Use production key for release builds
            guard let apiKey = Bundle.main.object(forInfoDictionaryKey: "REVENUECAT_API_KEY") as? String else {
                DebugLogger.shared.log("‚ùå FATAL: RevenueCat API key not found in Info.plist", level: .error)
                fatalError("RevenueCat API key not found in Info.plist")
            }
            DebugLogger.shared.log("‚úÖ Production API key found: \(apiKey.prefix(12))...", level: .info)
            #endif
            
            // Configure RevenueCat
            DebugLogger.shared.log("‚öôÔ∏è Calling Purchases.configure", level: .info)
            
            #if DEBUG
            // Enable debug logging and verbose logs for testing
            Purchases.logLevel = .debug
            Purchases.debugLogsEnabled = true
            
            // Check if we're using StoreKit Configuration file (local testing)
            let useStoreKitConfig = ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PREVIEWS"] != "1" &&
                                   Bundle.main.bundleURL.pathExtension == "app"
            
            if useStoreKitConfig {
                DebugLogger.shared.log("üß™ Using StoreKit Configuration file - setting up for local testing", level: .info)
                // Use StoreKit 2 testing mode
                Purchases.configure(
                    with: .builder(withAPIKey: apiKey)
                        .with(usesStoreKit2IfAvailable: true)
                        .with(storeKit1Timeout: 5)
                        .build()
                )
            } else {
                // Normal configuration
                Purchases.configure(withAPIKey: apiKey)
            }
            
            // Enable StoreKit testing mode when using local StoreKit configuration files
            Purchases.simulatesAskToBuyInSandbox = true
            
            DebugLogger.shared.log("‚úÖ RevenueCat SDK configured (DEBUG mode with verbose logging)", level: .info)
            #else
            Purchases.configure(withAPIKey: apiKey)
            DebugLogger.shared.log("‚úÖ RevenueCat SDK configured", level: .info)
            #endif
            
            // Check initial user ID
            let initialUserId = Purchases.shared.appUserID
            DebugLogger.shared.log("üë§ Initial anonymous user ID: \(initialUserId)", level: .info)
            
            // Get or create user ID
            let receiptKey = "purchase_receipt_id"
            DebugLogger.shared.log("üîç Checking keychain for existing receipt ID", level: .info)
            let existingReceiptId = KeychainManager.shared.retrieve(String.self, forKey: receiptKey)
            
            // Check if existing ID is invalid (like "0")
            let isValidUserId = existingReceiptId != nil && existingReceiptId != "0" && !existingReceiptId!.isEmpty
            let userId = isValidUserId ? existingReceiptId! : UUID().uuidString
            
            if !isValidUserId {
                DebugLogger.shared.log("üö® Invalid existing receipt ID detected ('\(existingReceiptId ?? "nil")'), generating new UUID", level: .info)
            }
            
            DebugLogger.shared.log("üîç User ID to use: \(userId.prefix(8))... (existing: \(existingReceiptId != nil ? "yes" : "no"))", level: .info)
            
            // Set user ID immediately to avoid "0" issue
            DebugLogger.shared.log("üîÑ Calling Purchases.shared.logIn", level: .info)
            Purchases.shared.logIn(userId) { (customerInfo, created, error) in
                if let error = error {
                    DebugLogger.shared.log("‚ùå RevenueCat login failed: \(error.localizedDescription)", level: .error)
                    DebugLogger.shared.log("üîß User ID after failed login: \(Purchases.shared.appUserID)", level: .info)
                } else {
                    DebugLogger.shared.log("‚úÖ RevenueCat user ID set successfully: \(userId.prefix(8))...", level: .info)
                    
                    // Store new ID if it didn't exist or was invalid
                    if !isValidUserId {
                        _ = KeychainManager.shared.store(userId, forKey: receiptKey)
                        DebugLogger.shared.log("üíæ Stored new user ID in keychain", level: .info)
                    }
                }
                
                // Log final user ID for verification
                let finalUserId = Purchases.shared.appUserID
                DebugLogger.shared.log("üéØ Final RevenueCat user ID: \(finalUserId)", level: .info)
                
                // Additional verification
                if finalUserId == "0" {
                    DebugLogger.shared.log("üö® WARNING: User ID is still '0' - this will cause API failures!", level: .error)
                } else {
                    DebugLogger.shared.log("‚úÖ User ID successfully set to non-zero value", level: .info)
                }
            }
            
            // Enable debug logs for testing
            Purchases.logLevel = .debug
            DebugLogger.shared.log("üìä RevenueCat debug logs enabled", level: .info)
            
            DebugLogger.shared.log("‚úÖ RevenueCat configuration complete", level: .info)
            
        } catch {
            DebugLogger.shared.log("‚ùå EXCEPTION in configureRevenueCat: \(error.localizedDescription)", level: .error)
            // Don't let RevenueCat configuration failures crash the app
        }
    }
    
    /// Register background task handlers (required in didFinishLaunchingWithOptions)
    private func registerBackgroundTasks() {
        // Audio prefetch background task
        BGTaskScheduler.shared.register(forTaskWithIdentifier: "ai.bananaintelligence.DayStart.audio-prefetch", using: nil) { task in
            // Handler will be set up when AudioPrefetchManager is loaded
            if ServiceRegistry.shared.loadedServices.contains("AudioPrefetchManager") {
                ServiceRegistry.shared.audioPrefetchManager.handleBackgroundTask(task: task as! BGProcessingTask)
            } else {
                // Service not loaded yet, fail the task
                task.setTaskCompleted(success: false)
            }
        }
        
        // Snapshot update background task  
        BGTaskScheduler.shared.register(forTaskWithIdentifier: "ai.bananaintelligence.DayStart.snapshot-update", using: nil) { task in
            // Handler will be set up when SnapshotUpdateManager is loaded
            if ServiceRegistry.shared.loadedServices.contains("SnapshotUpdateManager") {
                ServiceRegistry.shared.snapshotUpdateManager.handleBackgroundTask(task: task as! BGProcessingTask)
            } else {
                // Service not loaded yet, fail the task
                task.setTaskCompleted(success: false)
            }
        }
        
        DebugLogger.shared.log("‚úÖ Background task handlers registered in AppDelegate", level: .info)
    }
    
    func applicationWillEnterForeground(_ application: UIApplication) {
        // LAZY: Only check if services are already loaded
        Task.detached {
            await MainActor.run {
                let registry = ServiceRegistry.shared
                if registry.loadedServices.contains("AudioPrefetchManager") {
                    Task {
                        await registry.audioPrefetchManager.checkForUpcomingDayStarts()
                    }
                }
            }
        }
    }
    
    func applicationDidEnterBackground(_ application: UIApplication) {
        // LAZY: Only clean cache if AudioCache is loaded
        Task {
            await MainActor.run {
                let registry = ServiceRegistry.shared
                if registry.loadedServices.contains("AudioCache") {
                    registry.audioCache.clearOldCache()
                }
            }
        }
    }
    
    func applicationWillTerminate(_ application: UIApplication) {
        // LAZY: Only cancel if services are loaded
        Task { @MainActor in
            let registry = ServiceRegistry.shared
            
            if registry.loadedServices.contains("AudioDownloader") {
                registry.audioDownloader.cancelAllDownloads()
            }
            
            if registry.loadedServices.contains("AudioPrefetchManager") {
                registry.audioPrefetchManager.cancelAllBackgroundTasks()
            }
        }
    }
}